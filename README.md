# 1-2：ES 新特性与 TypeScript、JS 性能优化

### 简答题：

------

### 一、请说出下列最终的执行结果，并解释为什么

```
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[6]()
```

答：10

原因：var定义变量，变量提升，作用域是函数体的全部。for循环执行完后i=10



### 二、请说出下列最终的执行结果，并解释为什么

```
var tmp = 123
if (true) {
    console.log(tmp)
    let tmp
}

// =>ReferenceError: Cannot access 'tmp' before initialization
```

答：报错

原因：let 声明变量仅在块中生效且不会变量提升，在声明变量前调用变量会报错



### 三、结合ES6新语法，用最简单的方式找出数组中的最小值

```
var arr = [12,34,32,89,4];
```

答：

```
let min = arr[0];
for(const item of arr){
    min = item < min ? item : min;
}
console.log('min===', min)
```



### 四、请详细说明var、let、const三种变量声明的方式之间的具体差别

答：

- 作用域：

  - var作用域--函数体的全部

  - let作用域--块级作用域

- 变量提升：

  - var——存在变量提升，可先使用变量后声明变量
  - let——不存在变量提升，先使用后声明会报错，作用域外部访问作用域内部let声明的成员报错

- 重复定义：

  - var修饰的变量可重复定义`var a = 1; var a = 2 `
  - let修饰的变量不可重复定义，重复定义报错
  
- 修改：

  - const定义常量，不可修改。

    >  注意：const定义对象，对象内部的属性可修改，但指向的内存地址不能被更改。(不推荐)
    >
    > ```
    > const a = {bb: 6};
    > a = 6; // => TypeError: Assignment to constant variable.
    > a.bb = 6; 
    > console.log(a); // => {bb: 6}
    > ```
    >
    > 

  - var、let定义的变量可以修改。



### 五、请说出下列代码最终输出的结果，并解释为什么。

```
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a);
        })
    }
}
obj.fn(); // => 20
```

答：20

原因：定时器为箭头函数，this指向最近的函数this指向。最近的函数是fn，fn函数中的this指向obj，所以this也指向obj，this.a即obj.a，所以输出20。



### 六、简述`Symbol`类型的用途。

答：

- 唯一性：e.g为对象添加独一无二的属性名

```
// 两个 Symbol 永远不会相等
console.log(
  Symbol() === Symbol()
)

// 使用 Symbol 为对象添加用不重复的键
const obj = {}
obj[Symbol()] = '123'
obj[Symbol()] = '456'
console.log(obj) // { [Symbol()]: '123', [Symbol()]: '456' }
```

- 定义私有属性：e.g为对象实现迭代器





### 七、说说什么是浅拷贝，什么是深拷贝？

答：简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。

> 基本数据类型：**String、Number、Boolean、Null、Undefined、Symbol**
>
> 引用数据类型：**Object（Object、Array、Function）**

（1）**赋值**

赋值是将某一**数值或对象**赋给某个**变量**的过程，分为：

1、**基本数据类型**：赋值，赋值之后两个变量互不影响

2、**引用数据类型**：赋**址**（引用地址），两个变量具有相同的引用，指向同一个对象，相互之间有影响

对基本类型进行赋值操作，两个变量互不影响。

对引用类型进行赋**址**操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a 中的基本类型数据。

```
// 基本数据类型 赋值
let a = 11;
let b = a;
console.log(b) // => 11

b = 22;
console.log(b) // => 22
console.log(a) // => 11

// 引用数据类型 赋引用地址
let obj1 = {aa: '1', bb: { s1: '21', s2: '22'}};
let obj2 = obj1;
console.log(obj2); // => {aa: "1",bb: {s1: 21, s2: "22"}}

obj2.bb.s1 = 33;
console.log(obj2); // => {aa: "1",bb: {s1: 33, s2: "22"}}

console.log(obj1); // => {aa: "1",bb: {s1: 33, s2: "22"}}


```

**（2）浅拷贝和深拷贝**

**浅拷贝：**

拷贝第一层的**基本类型值**，以及第一层的**引用类型地址**。

**深拷贝：**

针对引用数据，引用地址不同，值相同



### 八、请简述TypeScript与JavaScript之间的关系

答：

**JavaScript**是一种脚本编写语言，无需编译，只要嵌入HTML代码中，就能在浏览器中加载执行。

**TypeScript**是开源的编程语言。它是JavaScript的一个超集，向JavaScript添加了可选的静态类型和基于类的面向对象编程，是一种给 JavaScript 添加特性的语言扩展。且可编译成纯JavaScript。

JavaScript能够直接在浏览器引擎和node.js上直接运行，但是TypeScript不可以。

> 超集：理解为，容器A（TypeScript）中包含容器B（JavaScript），A中可能包含B没有的元素，称A为B的超集，若A中一定包含B没有的元素，称A为B的真超集

### 九、请谈谈你所认为的TypeScript优缺点

答：

**优点：**

- 增强了代码的可读性和可维护性
- 兼容性好：
  - TypeScript 是 JavaScript 的超集，`.js` 文件可以直接重命名为 `.ts` 即可
  - 即使不显式的定义类型，也能够自动做出类型推论
  - 可以定义从简单到复杂的几乎一切类型
  - 即使 TypeScript 编译报错，也可以生成 JavaScript 文件
  - 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取

**缺点：**

- 增加学习成本
- 增加开发成本
- 增加集成、构建成本

### 十、描述引用计数的工作原理和优缺点

答：

**引用计数的工作原理：**设置对象的引用数，引用关系改变时修改引用数。判断当前对象引用数是否为0，引用数为0时立即回收。

**优点：**

- 及时回收垃圾对象
- 减少程序卡顿

**缺点：**

- 无法回收循环引用的对象
- 引用数过多，资源消耗会较大

### 十一、描述标记整理算法的工作流程

答：

- 标记：遍历所有对象找标记可访问到的对象
- 整理、清除：遍历对象，整理移动没有标记的对象，然后回收相应的空间

### 十二、描述V8中新生代存储区垃圾回收的流程

答：

- 回收过程采用复制算法+标记整理算法

- 新生代内存区分为两个等大小空间 From 和 To。使用空间为 From，空闲空间为 To
- 活动对象存储在 From 空间，标记整理后将活动对象拷贝至 To
- 拷贝过程中可能出现晋升（晋升就是将新生代对象移动至老生代）。
- 一轮 GC 还存活的新生代需要晋升；To 空间使用率超过 25%，也要将活动对象移动至老生代。
- 最后将 From 与 To 交换空间完成内存释放

### 十三、描述增量标记算法在何时使用及工作原理

答：

**增量标记算法：**将一整段的垃圾回收操作，拆分成多个小步，组合完成整个垃圾回收操作。我们知道，当垃圾回收工作的时候，会阻塞JS程序执行，当我们需要优化垃圾回收的效率时，就可以使用增量标记算法。

**工作原理：**

- JS 程序执行的过程中，会伴随着垃圾回收的工作
- 当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，此时停下标记操作
- 然后让JS程序执行一会，之后，再让 GC 机制去做二步的标记操作，去标记那些间接可达的对象
- 重复以上两步，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的
- 直到标记操作完成之后，最后执行垃圾回收













